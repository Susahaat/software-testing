// ceil.ai.test.js
// These tests were generated by an AI without modifying them after
import ceil from '../src/ceil.js';

describe('ceil', () => {
  describe('Rounding with default precision (0)', () => {
    test('returns the same value for integers', () => {
      expect(ceil(4)).toBe(4);
      expect(ceil(0)).toBe(0);
    });

    test('rounds up positive decimal numbers to the next integer', () => {
      expect(ceil(4.006)).toBe(5);
      expect(ceil(1.0001)).toBe(2);
      expect(ceil(1.9999)).toBe(2);
      expect(ceil(0.0001)).toBe(1);
    });

    test('rounds up negative decimal numbers toward zero (toward +Infinity)', () => {
      expect(ceil(-4.006)).toBe(-4);
      expect(ceil(-1.2)).toBe(-1);
      expect(ceil(-1)).toBe(-1);
      expect(ceil(-1.0001)).toBe(-1);
      expect(ceil(-0.0001)).toBe(0);
    });
  });

  describe('Rounding with positive precision', () => {
    test('rounds up to the specified number of decimal places', () => {
      expect(ceil(6.004, 2)).toBe(6.01);
      expect(ceil(0.555, 2)).toBe(0.56);
      expect(ceil(1.23001, 4)).toBe(1.2301);
      expect(ceil(9.999, 3)).toBe(10.0); // may display as 10 in JS, but numerically correct
    });

    test('handles negative numbers with positive precision correctly', () => {
      expect(ceil(-6.004, 2)).toBe(-6.0);
      expect(ceil(-0.555, 2)).toBe(-0.55);
      expect(ceil(-0.001, 3)).toBe(-0.001);
    });
  });

  describe('Rounding with negative precision (tens, hundreds, etc.)', () => {
    test('rounds up to the nearest multiple of 10, 100, etc.', () => {
      expect(ceil(6040, -2)).toBe(6100);
      expect(ceil(10, -1)).toBe(10); // already a multiple of 10
      expect(ceil(11, -1)).toBe(20);
      expect(ceil(190, -2)).toBe(200);
      expect(ceil(999, -3)).toBe(1000);
    });

    test('handles negative numbers with negative precision correctly', () => {
      // Smallest number >= -6040 at hundreds is -6000
      expect(ceil(-6040, -2)).toBe(-6000);
      expect(ceil(-11, -1)).toBe(-10);
      expect(ceil(-101, -2)).toBe(-100);
    });
  });

  test('rounds up to the nearest integer when precision is omitted', () => {
    expect(ceil(4.006)).toBe(5);
    expect(ceil(4)).toBe(4);
    expect(ceil(-4.006)).toBe(-4);
  });

  test('handles precision greater than the number of decimals without changing the value', () => {
    expect(ceil(1.2345, 10)).toBe(1.2345);
  });

  test('returns NaN for invalid inputs', () => {
    // Depending on your createRound implementation, strings may be coerced.
    // These are conservative: if you want coercion, adjust expectations
    expect(ceil('abc')).toBeNaN();
    expect(ceil(undefined)).toBeNaN();
  });

  test('handles Infinity and -Infinity correctly', () => {
    expect(ceil(Infinity)).toBe(Infinity);
    expect(ceil(-Infinity)).toBe(-Infinity);
    expect(ceil(Infinity, 2)).toBe(Infinity);
    expect(ceil(-Infinity, 2)).toBe(-Infinity);
  });
});
